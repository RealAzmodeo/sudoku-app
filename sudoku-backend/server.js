const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');
const bodyParser = require('body-parser');
const { GoogleGenerativeAI } = require("@google/generative-ai");
const multer = require('multer');

// Configure Gemini
// SECURITY: API Key must be set in Environment Variables (Render Dashboard)
const GEN_AI_KEY = process.env.GEMINI_API_KEY;

if (!GEN_AI_KEY) {
    console.error("âŒ CRITICAL ERROR: GEMINI_API_KEY is not set in environment variables!");
}

const genAI = new GoogleGenerativeAI(GEN_AI_KEY);
// Using the available model confirmed via diagnostic
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

// Configure Multer (Uploads in memory)
const upload = multer({ storage: multer.memoryStorage() });

const app = express();
const PORT = 3000;

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: '50mb' })); 

// Database Setup
const db = new sqlite3.Database('./sudoku.db', (err) => {
  if (err) {
    console.error('Error opening database', err.message);
  } else {
    console.log('Connected to the SQLite database.');
    
    // Create Tables
    db.run(`CREATE TABLE IF NOT EXISTS puzzles (
      id TEXT PRIMARY KEY,
      initialGrid TEXT,
      solvedGrid TEXT,
      difficulty TEXT,
      author TEXT,
      createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Migration helper: Try to add author column if it doesn't exist (for existing DBs)
    db.run(`ALTER TABLE puzzles ADD COLUMN author TEXT`, (err) => {
        // Ignore error if column already exists
    });

    db.run(`CREATE TABLE IF NOT EXISTS scores (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      puzzleId TEXT,
      playerName TEXT,
      installationId TEXT,
      timeSeconds INTEGER,
      mistakes INTEGER,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    
    // Migration: Add installationId column if missing
    try {
        db.run(`ALTER TABLE scores ADD COLUMN installationId TEXT`, () => {});
    } catch(e) {}
  }
});

// --- API ROUTES ---

// 0. AI SCAN ROUTE
app.get('/api/ping', (req, res) => {
    res.json({ status: "alive", timestamp: new Date() });
});

// New Route: List Community Puzzles with User Status
app.get('/api/puzzles', (req, res) => {
    const { installationId } = req.query;
    
    const query = `
      SELECT 
        p.id, 
        p.difficulty, 
        p.author, 
        p.createdAt, 
        COUNT(s.id) as plays,
        MAX(CASE WHEN s.installationId = ? THEN 1 ELSE 0 END) as userCompleted
      FROM puzzles p
      LEFT JOIN scores s ON p.id = s.puzzleId
      GROUP BY p.id
      ORDER BY p.createdAt DESC 
      LIMIT 50
    `;
    
    db.all(query, [installationId || ''], (err, rows) => {
        if (err) {
            return res.status(500).json({ error: err.message });
        }
        res.json(rows);
    });
});

app.post('/api/scan', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No image uploaded' });
        }

        console.log("Analyzing image with Gemini 2.5 Flash...");

        // Convert buffer to base64 for Gemini
        const imagePart = {
            inlineData: {
                data: req.file.buffer.toString("base64"),
                mimeType: req.file.mimetype,
            },
        };

        const prompt = `
            Analyze this image of a Sudoku puzzle.
            Extract the numbers into a 9x9 grid.
            Represent empty cells as 0.
            Return ONLY a valid JSON 2D array (matrix) of integers.
            Example format: [[5,3,0...], [6,0,0...], ...]
            Do not include markdown formatting or explanations.
        `;

        const result = await model.generateContent([prompt, imagePart]);
        const response = await result.response;
        const text = response.text();
        
        console.log("Gemini Response OK");

        // Clean up markdown if Gemini adds it
        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
        
        try {
            const grid = JSON.parse(cleanText);
            res.json({ grid });
        } catch (parseError) {
            console.error("JSON Parse Error. Raw text was:", cleanText);
            res.status(500).json({ error: "AI returned invalid format", raw: cleanText });
        }

    } catch (error) {
        console.error("Gemini Scan Error:", error);
        
        // Return the specific error message to the client for debugging
        res.status(500).json({ 
            error: "Gemini Error", 
            message: error.message,
            suggestion: "Please check Render Logs for 'ALL AVAILABLE MODELS' list."
        });
    }
});

// 1. Save a new Puzzle (Generated by the app)
app.post('/api/puzzle', (req, res) => {
  const { id, initialGrid, solvedGrid, difficulty, author } = req.body;
  
  if (!id || !initialGrid || !solvedGrid) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const query = `INSERT OR IGNORE INTO puzzles (id, initialGrid, solvedGrid, difficulty, author) VALUES (?, ?, ?, ?, ?)`;
  db.run(query, [id, JSON.stringify(initialGrid), JSON.stringify(solvedGrid), difficulty, author || 'Anonymous'], function(err) {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json({ message: 'Puzzle saved', id });
  });
});

// 2. Get a Puzzle by ID
app.get('/api/puzzle/:id', (req, res) => {
  const { id } = req.params;
  db.get(`SELECT * FROM puzzles WHERE id = ?`, [id], (err, row) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    if (!row) {
      return res.status(404).json({ error: 'Puzzle not found' });
    }
    res.json({
      id: row.id,
      initialGrid: JSON.parse(row.initialGrid),
      solvedGrid: JSON.parse(row.solvedGrid),
      difficulty: row.difficulty
    });
  });
});

// 3. Submit a Score
app.post('/api/score', (req, res) => {
  const { puzzleId, playerName, timeSeconds, mistakes, installationId } = req.body;
  
  const query = `INSERT INTO scores (puzzleId, playerName, timeSeconds, mistakes, installationId) VALUES (?, ?, ?, ?, ?)`;
  db.run(query, [puzzleId, playerName, timeSeconds, mistakes, installationId || 'unknown'], function(err) {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json({ message: 'Score saved', id: this.lastID });
  });
});

// 4. Get Leaderboard (Global or by Puzzle)
app.get('/api/leaderboard', (req, res) => {
  const { puzzleId } = req.query;
  
  let query = `SELECT * FROM scores ORDER BY mistakes ASC, timeSeconds ASC LIMIT 50`;
  let params = [];

  if (puzzleId) {
    query = `SELECT * FROM scores WHERE puzzleId = ? ORDER BY mistakes ASC, timeSeconds ASC LIMIT 50`;
    params = [puzzleId];
  }

  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// 5. Update Author Name (Renaming User)
app.put('/api/update-author', (req, res) => {
    const { oldName, newName } = req.body;
    if (!oldName || !newName) return res.status(400).json({ error: "Names required" });

    // Update in Puzzles
    db.run(`UPDATE puzzles SET author = ? WHERE author = ?`, [newName, oldName], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        
        // Also update in Scores if we want to keep consistency (Optional but good)
        db.run(`UPDATE scores SET playerName = ? WHERE playerName = ?`, [newName, oldName], (err2) => {
             res.json({ message: "Author updated", changes: this.changes });
        });
    });
});

// Start Server - Version 1.1 with Gemini
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on http://0.0.0.0:${PORT}`);
});
