const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');
const bodyParser = require('body-parser');
const { GoogleGenerativeAI } = require("@google/generative-ai");
const multer = require('multer');

// Configure Gemini
const GEN_AI_KEY = process.env.GEMINI_API_KEY || "AIzaSyBUg_kvKuzz-Rul8GqHXXf1TzBOKMN1zp0";
const genAI = new GoogleGenerativeAI(GEN_AI_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

// Configure Multer (Uploads in memory)
const upload = multer({ storage: multer.memoryStorage() });

const app = express();
const PORT = 3000;

// Middleware
app.use(cors());
app.use(bodyParser.json({ limit: '50mb' })); // Increase limit for images

// Database Setup
const db = new sqlite3.Database('./sudoku.db', (err) => {
  if (err) {
    console.error('Error opening database', err.message);
  } else {
    console.log('Connected to the SQLite database.');
    
    // Create Tables
    db.run(`CREATE TABLE IF NOT EXISTS puzzles (
      id TEXT PRIMARY KEY,
      initialGrid TEXT,
      solvedGrid TEXT,
      difficulty TEXT,
      createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS scores (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      puzzleId TEXT,
      playerName TEXT,
      timeSeconds INTEGER,
      mistakes INTEGER,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
  }
});

// --- API ROUTES ---

// 0. AI SCAN ROUTE (New!)
app.post('/api/scan', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No image uploaded' });
        }

        console.log("Analyzing image with Gemini...");

        // Convert buffer to base64 for Gemini
        const imagePart = {
            inlineData: {
                data: req.file.buffer.toString("base64"),
                mimeType: req.file.mimetype,
            },
        };

        const prompt = `
            Analyze this image of a Sudoku puzzle.
            Extract the numbers into a 9x9 grid.
            Represent empty cells as 0.
            Return ONLY a valid JSON 2D array (matrix) of integers.
            Example format: [[5,3,0...], [6,0,0...], ...]
            Do not include markdown formatting or explanations.
        `;

        const result = await model.generateContent([prompt, imagePart]);
        const response = await result.response;
        const text = response.text();
        
        console.log("Gemini Raw Response:", text); // Debugging

        // Clean up markdown if Gemini adds it (```json ... ```)
        const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
        
        try {
            const grid = JSON.parse(cleanText);
            res.json({ grid });
        } catch (parseError) {
            console.error("JSON Parse Error. Raw text was:", cleanText);
            res.status(500).json({ error: "AI returned invalid format", raw: cleanText });
        }

    } catch (error) {
        console.error("Gemini Scan Error:", error);
        // Return the specific error message to the client for debugging
        res.status(500).json({ error: error.message, details: error.toString() });
    }
});

// 1. Save a new Puzzle (Generated by the app)
app.post('/api/puzzle', (req, res) => {
  const { id, initialGrid, solvedGrid, difficulty } = req.body;
  
  if (!id || !initialGrid || !solvedGrid) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const query = `INSERT OR IGNORE INTO puzzles (id, initialGrid, solvedGrid, difficulty) VALUES (?, ?, ?, ?)`;
  db.run(query, [id, JSON.stringify(initialGrid), JSON.stringify(solvedGrid), difficulty], function(err) {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json({ message: 'Puzzle saved', id });
  });
});

// 2. Get a Puzzle by ID
app.get('/api/puzzle/:id', (req, res) => {
  const { id } = req.params;
  db.get(`SELECT * FROM puzzles WHERE id = ?`, [id], (err, row) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    if (!row) {
      return res.status(404).json({ error: 'Puzzle not found' });
    }
    res.json({
      id: row.id,
      initialGrid: JSON.parse(row.initialGrid),
      solvedGrid: JSON.parse(row.solvedGrid),
      difficulty: row.difficulty
    });
  });
});

// 3. Submit a Score
app.post('/api/score', (req, res) => {
  const { puzzleId, playerName, timeSeconds, mistakes } = req.body;
  
  const query = `INSERT INTO scores (puzzleId, playerName, timeSeconds, mistakes) VALUES (?, ?, ?, ?)`;
  db.run(query, [puzzleId, playerName, timeSeconds, mistakes], function(err) {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json({ message: 'Score saved', id: this.lastID });
  });
});

// 4. Get Leaderboard (Global or by Puzzle)
app.get('/api/leaderboard', (req, res) => {
  const { puzzleId } = req.query;
  
  let query = `SELECT * FROM scores ORDER BY mistakes ASC, timeSeconds ASC LIMIT 50`;
  let params = [];

  if (puzzleId) {
    query = `SELECT * FROM scores WHERE puzzleId = ? ORDER BY mistakes ASC, timeSeconds ASC LIMIT 50`;
    params = [puzzleId];
  }

  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// Start Server - Version 1.1 with Gemini
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on http://0.0.0.0:${PORT}`);
});
